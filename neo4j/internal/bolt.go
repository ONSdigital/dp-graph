// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package internal

import (
	"github.com/ONSdigital/dp-graph/v2/neo4j/neo4jdriver"
	"sync"
)

// Ensure, that ResultMock does implement neo4jdriver.Result.
// If this is not the case, regenerate this file with moq.
var _ neo4jdriver.Result = &ResultMock{}

// ResultMock is a mock implementation of neo4jdriver.Result.
//
//	func TestSomethingThatUsesResult(t *testing.T) {
//
//		// make and configure a mocked neo4jdriver.Result
//		mockedResult := &ResultMock{
//			LastInsertIdFunc: func() (int64, error) {
//				panic("mock out the LastInsertId method")
//			},
//			MetadataFunc: func() map[string]interface{} {
//				panic("mock out the Metadata method")
//			},
//			RowsAffectedFunc: func() (int64, error) {
//				panic("mock out the RowsAffected method")
//			},
//		}
//
//		// use mockedResult in code that requires neo4jdriver.Result
//		// and then make assertions.
//
//	}
type ResultMock struct {
	// LastInsertIdFunc mocks the LastInsertId method.
	LastInsertIdFunc func() (int64, error)

	// MetadataFunc mocks the Metadata method.
	MetadataFunc func() map[string]interface{}

	// RowsAffectedFunc mocks the RowsAffected method.
	RowsAffectedFunc func() (int64, error)

	// calls tracks calls to the methods.
	calls struct {
		// LastInsertId holds details about calls to the LastInsertId method.
		LastInsertId []struct {
		}
		// Metadata holds details about calls to the Metadata method.
		Metadata []struct {
		}
		// RowsAffected holds details about calls to the RowsAffected method.
		RowsAffected []struct {
		}
	}
	lockLastInsertId sync.RWMutex
	lockMetadata     sync.RWMutex
	lockRowsAffected sync.RWMutex
}

// LastInsertId calls LastInsertIdFunc.
func (mock *ResultMock) LastInsertId() (int64, error) {
	if mock.LastInsertIdFunc == nil {
		panic("ResultMock.LastInsertIdFunc: method is nil but Result.LastInsertId was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLastInsertId.Lock()
	mock.calls.LastInsertId = append(mock.calls.LastInsertId, callInfo)
	mock.lockLastInsertId.Unlock()
	return mock.LastInsertIdFunc()
}

// LastInsertIdCalls gets all the calls that were made to LastInsertId.
// Check the length with:
//
//	len(mockedResult.LastInsertIdCalls())
func (mock *ResultMock) LastInsertIdCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLastInsertId.RLock()
	calls = mock.calls.LastInsertId
	mock.lockLastInsertId.RUnlock()
	return calls
}

// Metadata calls MetadataFunc.
func (mock *ResultMock) Metadata() map[string]interface{} {
	if mock.MetadataFunc == nil {
		panic("ResultMock.MetadataFunc: method is nil but Result.Metadata was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMetadata.Lock()
	mock.calls.Metadata = append(mock.calls.Metadata, callInfo)
	mock.lockMetadata.Unlock()
	return mock.MetadataFunc()
}

// MetadataCalls gets all the calls that were made to Metadata.
// Check the length with:
//
//	len(mockedResult.MetadataCalls())
func (mock *ResultMock) MetadataCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMetadata.RLock()
	calls = mock.calls.Metadata
	mock.lockMetadata.RUnlock()
	return calls
}

// RowsAffected calls RowsAffectedFunc.
func (mock *ResultMock) RowsAffected() (int64, error) {
	if mock.RowsAffectedFunc == nil {
		panic("ResultMock.RowsAffectedFunc: method is nil but Result.RowsAffected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRowsAffected.Lock()
	mock.calls.RowsAffected = append(mock.calls.RowsAffected, callInfo)
	mock.lockRowsAffected.Unlock()
	return mock.RowsAffectedFunc()
}

// RowsAffectedCalls gets all the calls that were made to RowsAffected.
// Check the length with:
//
//	len(mockedResult.RowsAffectedCalls())
func (mock *ResultMock) RowsAffectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRowsAffected.RLock()
	calls = mock.calls.RowsAffected
	mock.lockRowsAffected.RUnlock()
	return calls
}
